package com.santiagoone.training.rxjavaexamples;

import io.reactivex.*;
import io.reactivex.disposables.Disposable;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;


/**
 * Created by Ricardo Alexis Quiroz Bazan 01/04/17
 */
public class CreatingObservable {
    private static final Logger logger = LogManager.getLogger(CreatingObservable.class);

    //Util class
    private CreatingObservable() {

    }

    public static void theMostSimpleAndVerboseWay() {
        logger.info("Begin");

        Observable<Integer> observable = Observable.create(emitter -> {
            try {
                emitter.onNext(1);
                emitter.onNext(2);
                emitter.onNext(3);
                emitter.onComplete();
            }catch (Throwable e) {
                emitter.onError(e);
            }
        });

        Observer<Integer> observer = new Observer<Integer>() {
            @Override
            public void onSubscribe(Disposable disposable) {
                logger.info("disposable = " + disposable);
            }

            @Override
            public void onNext(Integer integer) {
                logger.info("integer = " + integer);
            }

            @Override
            public void onError(Throwable throwable) {
                logger.info("throwable = " + throwable);
            }

            @Override
            public void onComplete() {
                logger.info("Completed");
            }
        };

        observable.subscribe(observer);

        logger.info("End");
    }

    public static void theMostSimpleWay() {
        logger.info("Begin");

        Observable.just(1, 2, 3)
                .subscribe(logger::info, logger::error, () -> logger.info("Completed"));

        logger.info("End");
    }

    public static void thatEmitsASingleValue() {
        logger.info("Begin");

        Observable.fromCallable(() -> "This string could be the value generated by a computation")
                .subscribe(logger::info, logger::error, () -> logger.info("Completed"));

        logger.info("End");
    }

    public static void thatEmitsASingleValueWithSingleClass() {
        logger.info("Begin");

        Observable.just(1, 2, 3) // the observable emits three values
                .toList() // the observable is converted to a single: a built-observable that emits a single value
                .subscribe(new SingleObserver<List<Integer>>() {
                    @Override
                    public void onSubscribe(Disposable disposable) {
                        logger.info("is disposed = " + disposable.isDisposed());
                    }

                    @Override
                    public void onSuccess(List<Integer> aValue) {
                        logger.info("a value = " + aValue);
                    }

                    @Override
                    public void onError(Throwable throwable) {
                        logger.error(throwable);
                    }
                });

        Single.just("Hello RxJava")
                .subscribe(new SingleObserver<String>() {
                    @Override
                    public void onSubscribe(Disposable disposable) {
                        logger.info("is disposed = " + disposable.isDisposed());
                    }

                    @Override
                    public void onSuccess(String s) {
                        logger.info("a value = " + s);
                    }

                    @Override
                    public void onError(Throwable throwable) {
                        logger.error(throwable);
                    }
                });

        logger.info("End");
    }

    /*
    * There are many method to join the results from multiples observable,
    * the difference between those is the way they combine the observables.
    *
    * Reference: https://github.com/ReactiveX/RxJava/wiki/Combining-Observables
    *
    * */
    public static void fromMultiplesObservables() {
        logger.info("Begin");

        Observable<Integer> observable1 = Observable.just(1, 2);
        Observable<String> observable2 = Observable.fromCallable(() -> "I'm a value");
        Observable<Integer> observable3 = Observable.range(3, 4);

        Observable.concat(observable1, observable2, observable3)
                .subscribe(logger::info, logger::error, () -> logger.info("Completed"));

        List<Observable<Integer>> observables = new ArrayList<>();
        observables.add(observable1);
        observables.add(observable3);

        Observable.concat(observables) //useful to multiples observables that emits the same type value
                .subscribe(logger::info, logger::error, () -> logger.info("Completed"));

        logger.info("End");
    }

    public static void fromCollection() {
        logger.info("Begin");

        Object[] array1 = new Object[]{1, 2, 3};
        int[] array2 = new int[]{4, 5, 6};

        Observable.fromArray(1, 2, "0x11010")
                .subscribe(logger::info, logger::error, () -> logger.info("Completed"));
        Observable.fromArray(array1)
                .subscribe(logger::info, logger::error, () -> logger.info("Completed"));

        /*
        * fromArray was implemented with Varargs (https://docs.oracle.com/javase/8/docs/technotes/guides/language/varargs.html)
        * thus fromArray retrieves a Object[] actually.
        * array2 is a int[] so, the real argument pass to fromArray method will be: new Object[]{ array2 }
        * */
        Observable.fromArray(array2)
                .subscribe(logger::info, logger::error, () -> logger.info("Completed"));

        List<Object> data = Arrays.asList("Hello", "RxJava");
        Observable.fromIterable(data)
                .subscribe(logger::info, logger::error, () -> logger.info("Completed"));

        logger.info("End");
    }

    /*
    * RxJava 2.x no longer accepts null values
    *
    * Reference: https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#nulls
    *
    * Here there will be an error (by null value),
    * so the onComplete method will be not invoked
    * */
    public static void noNullValues() {
        logger.info("Begin");

        Observable.fromCallable(() -> null)
                .subscribe(logger::info, logger::error, () -> logger.info("Completed"));

        logger.info("End");
    }

}
